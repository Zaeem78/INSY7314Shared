{"ast":null,"code":"var _jsxFileName = \"C:\\\\Users\\\\pc\\\\Desktop\\\\INSY7314Shared\\\\INSY7314\\\\INSY7314\\\\frontend\\\\src\\\\contexts\\\\SecurityContext.js\",\n  _s = $RefreshSig$(),\n  _s2 = $RefreshSig$();\nimport React, { createContext, useContext, useEffect, useState } from 'react';\nimport { useNavigate, useLocation } from 'react-router-dom';\nimport * as securityUtils from '../utils/security';\nimport { getCookie, setCookie, removeCookie } from '../utils/cookies';\nimport api from '../utils/api';\n\n// Create security context\nimport { jsxDEV as _jsxDEV } from \"react/jsx-dev-runtime\";\nconst SecurityContext = /*#__PURE__*/createContext();\n\n// Custom hook to use security context\nexport const useSecurity = () => {\n  _s();\n  const context = useContext(SecurityContext);\n  if (!context) {\n    throw new Error('useSecurity must be used within a SecurityProvider');\n  }\n  return context;\n};\n\n// Security provider component\n_s(useSecurity, \"b9L3QQ+jgeyIrH0NfHrJ8nn7VMU=\");\nexport const SecurityProvider = ({\n  children\n}) => {\n  _s2();\n  const [csrfToken, setCsrfToken] = useState('');\n  const [isInitialized, setIsInitialized] = useState(false);\n  const [securityConfig, setSecurityConfig] = useState({\n    cspEnabled: true,\n    xssProtection: true,\n    clickjackingProtection: true,\n    contentTypeOptions: true,\n    hstsEnabled: process.env.NODE_ENV === 'production'\n  });\n  const navigate = useNavigate();\n  const location = useLocation();\n\n  // Initialize security features\n  useEffect(() => {\n    const initializeSecurity = async () => {\n      try {\n        // Fetch CSRF token from the server\n        await fetchCsrfToken();\n\n        // Set up security headers\n        setupSecurityHeaders();\n\n        // Set up global error handling\n        setupErrorHandling();\n\n        // Protect against clickjacking\n        if (securityConfig.clickjackingProtection) {\n          document.addEventListener('DOMContentLoaded', () => {\n            if (window !== window.top) {\n              window.top.location = window.location;\n            }\n          });\n        }\n        setIsInitialized(true);\n      } catch (error) {\n        console.error('Failed to initialize security:', error);\n      }\n    };\n    initializeSecurity();\n\n    // Clean up event listeners\n    return () => {\n      // Any cleanup if needed\n    };\n  }, []);\n\n  // Set up security headers\n  const setupSecurityHeaders = () => {\n    if (securityConfig.cspEnabled) {\n      const meta = document.createElement('meta');\n      meta.httpEquiv = \"Content-Security-Policy\";\n      meta.content = \"default-src 'self'; script-src 'self' 'unsafe-inline' 'unsafe-eval'; style-src 'self' 'unsafe-inline'; img-src 'self' data: https:; font-src 'self' data:; connect-src 'self';\";\n      document.head.appendChild(meta);\n    }\n    if (securityConfig.xssProtection) {\n      const metaXSS = document.createElement('meta');\n      metaXSS.httpEquiv = \"X-XSS-Protection\";\n      metaXSS.content = \"1; mode=block\";\n      document.head.appendChild(metaXSS);\n    }\n    if (securityConfig.contentTypeOptions) {\n      const metaCTO = document.createElement('meta');\n      metaCTO.httpEquiv = \"X-Content-Type-Options\";\n      metaCTO.content = \"nosniff\";\n      document.head.appendChild(metaCTO);\n    }\n    if (securityConfig.clickjackingProtection) {\n      const metaFrameOptions = document.createElement('meta');\n      metaFrameOptions.httpEquiv = \"X-Frame-Options\";\n      metaFrameOptions.content = \"DENY\";\n      document.head.appendChild(metaFrameOptions);\n    }\n    if (securityConfig.hstsEnabled && window.location.protocol === 'https:') {\n      const metaHSTS = document.createElement('meta');\n      metaHSTS.httpEquiv = \"Strict-Transport-Security\";\n      metaHSTS.content = \"max-age=31536000; includeSubDomains\";\n      document.head.appendChild(metaHSTS);\n    }\n  };\n\n  // Set up global error handling\n  const setupErrorHandling = () => {\n    // Global error handler\n    window.onerror = (message, source, lineno, colno, error) => {\n      console.error('Global error:', {\n        message,\n        source,\n        lineno,\n        colno,\n        error\n      });\n      // Log to error tracking service\n      logError({\n        type: 'global',\n        message: message.toString(),\n        source,\n        lineno,\n        colno,\n        stack: error === null || error === void 0 ? void 0 : error.stack,\n        url: window.location.href,\n        timestamp: new Date().toISOString()\n      });\n      return false; // Don't suppress default error handling\n    };\n\n    // Unhandled promise rejections\n    window.addEventListener('unhandledrejection', event => {\n      var _event$reason, _event$reason2;\n      console.error('Unhandled rejection:', event.reason);\n      logError({\n        type: 'unhandled_rejection',\n        message: ((_event$reason = event.reason) === null || _event$reason === void 0 ? void 0 : _event$reason.message) || 'Unknown error',\n        stack: (_event$reason2 = event.reason) === null || _event$reason2 === void 0 ? void 0 : _event$reason2.stack,\n        url: window.location.href,\n        timestamp: new Date().toISOString()\n      });\n    });\n  };\n\n  // Log security-related errors\n  const logError = async errorData => {\n    try {\n      await api.post('/api/logs/error', {\n        ...errorData,\n        userAgent: navigator.userAgent,\n        language: navigator.language,\n        platform: navigator.platform,\n        cookiesEnabled: navigator.cookieEnabled,\n        screenSize: `${window.screen.width}x${window.screen.height}`,\n        viewportSize: `${window.innerWidth}x${window.innerHeight}`\n      });\n    } catch (error) {\n      console.error('Failed to log error:', error);\n    }\n  };\n\n  // Fetch CSRF token from the server\n  const fetchCsrfToken = async () => {\n    try {\n      // Check if we already have a valid token\n      const existingToken = getCookie('XSRF-TOKEN');\n      if (existingToken) {\n        setCsrfToken(existingToken);\n        return existingToken;\n      }\n\n      // Fetch new token from the server\n      const response = await api.get('/api/csrf-token');\n      const {\n        token\n      } = response.data;\n\n      // Store the token in a secure, HTTP-only cookie\n      setCookie('XSRF-TOKEN', token, {\n        secure: process.env.NODE_ENV === 'production',\n        sameSite: 'strict',\n        path: '/',\n        maxAge: 24 * 60 * 60 // 24 hours\n      });\n      setCsrfToken(token);\n      return token;\n    } catch (error) {\n      console.error('Failed to fetch CSRF token:', error);\n      throw error;\n    }\n  };\n\n  // Sanitize user input\n  const sanitizeInput = (input, options = {}) => {\n    return securityUtils.sanitizeAndValidate(input, options);\n  };\n\n  // Validate password strength\n  const validatePassword = password => {\n    return securityUtils.validatePassword(password);\n  };\n\n  // Check if the current route requires authentication\n  const requiresAuth = path => {\n    const publicPaths = ['/login', '/register', '/forgot-password', '/reset-password'];\n    return !publicPaths.some(publicPath => path.startsWith(publicPath));\n  };\n\n  // Check if the current route is accessible based on user role\n  const isRouteAccessible = (requiredRoles = []) => {\n    // Get user role from your auth context or state\n    const userRole = 'user'; // Replace with actual user role\n\n    if (requiredRoles.length === 0) return true;\n    if (!userRole) return false;\n    return requiredRoles.includes(userRole);\n  };\n\n  // Secure navigation\n  const secureNavigate = (path, options = {}) => {\n    const {\n      requireAuth = true,\n      requiredRoles = []\n    } = options;\n    if (requireAuth && !isAuthenticated()) {\n      // Redirect to login with a return URL\n      navigate(`/login?returnTo=${encodeURIComponent(path)}`);\n      return false;\n    }\n    if (requiredRoles.length > 0 && !isRouteAccessible(requiredRoles)) {\n      // Redirect to not authorized page\n      navigate('/unauthorized');\n      return false;\n    }\n\n    // Sanitize the path to prevent XSS\n    const sanitizedPath = securityUtils.sanitizeUrl(path) || '/';\n    navigate(sanitizedPath);\n    return true;\n  };\n\n  // Check if user is authenticated\n  const isAuthenticated = () => {\n    // Implement your authentication check here\n    // For example, check for a valid JWT token\n    const token = localStorage.getItem('authToken');\n    return !!token;\n  };\n\n  // Secure logout\n  const secureLogout = async () => {\n    try {\n      // Call logout API\n      await api.post('/api/auth/logout');\n\n      // Clear local storage\n      localStorage.removeItem('authToken');\n      localStorage.removeItem('user');\n\n      // Clear session storage\n      sessionStorage.clear();\n\n      // Clear cookies\n      removeCookie('XSRF-TOKEN');\n\n      // Redirect to login\n      navigate('/login');\n    } catch (error) {\n      console.error('Logout failed:', error);\n      // Even if API call fails, clear client-side auth state\n      localStorage.removeItem('authToken');\n      localStorage.removeItem('user');\n      sessionStorage.clear();\n      removeCookie('XSRF-TOKEN');\n      navigate('/login');\n    }\n  };\n\n  // Secure API request\n  const secureRequest = async (method, url, data = {}, options = {}) => {\n    try {\n      const response = await api({\n        method,\n        url,\n        data,\n        ...options,\n        headers: {\n          'X-Requested-With': 'XMLHttpRequest',\n          'X-CSRF-Token': csrfToken,\n          ...options.headers\n        }\n      });\n      return response;\n    } catch (error) {\n      var _error$response, _error$response2;\n      if (((_error$response = error.response) === null || _error$response === void 0 ? void 0 : _error$response.status) === 401) {\n        // Handle unauthorized (token expired, etc.)\n        await secureLogout();\n        navigate(`/login?sessionExpired=true&returnTo=${encodeURIComponent(location.pathname)}`);\n      } else if (((_error$response2 = error.response) === null || _error$response2 === void 0 ? void 0 : _error$response2.status) === 403) {\n        // Handle forbidden (insufficient permissions)\n        navigate('/unauthorized');\n      }\n      throw error;\n    }\n  };\n\n  // Security context value\n  const value = {\n    isInitialized,\n    csrfToken,\n    securityConfig,\n    sanitizeInput,\n    validatePassword,\n    isAuthenticated,\n    secureNavigate,\n    secureLogout,\n    secureRequest,\n    logError\n  };\n  return /*#__PURE__*/_jsxDEV(SecurityContext.Provider, {\n    value: value,\n    children: children\n  }, void 0, false, {\n    fileName: _jsxFileName,\n    lineNumber: 319,\n    columnNumber: 5\n  }, this);\n};\n_s2(SecurityProvider, \"a4sUGwk73Q0M/a1DW48pJxOWc2M=\", false, function () {\n  return [useNavigate, useLocation];\n});\n_c = SecurityProvider;\nexport default SecurityContext;\nvar _c;\n$RefreshReg$(_c, \"SecurityProvider\");","map":{"version":3,"names":["React","createContext","useContext","useEffect","useState","useNavigate","useLocation","securityUtils","getCookie","setCookie","removeCookie","api","jsxDEV","_jsxDEV","SecurityContext","useSecurity","_s","context","Error","SecurityProvider","children","_s2","csrfToken","setCsrfToken","isInitialized","setIsInitialized","securityConfig","setSecurityConfig","cspEnabled","xssProtection","clickjackingProtection","contentTypeOptions","hstsEnabled","process","env","NODE_ENV","navigate","location","initializeSecurity","fetchCsrfToken","setupSecurityHeaders","setupErrorHandling","document","addEventListener","window","top","error","console","meta","createElement","httpEquiv","content","head","appendChild","metaXSS","metaCTO","metaFrameOptions","protocol","metaHSTS","onerror","message","source","lineno","colno","logError","type","toString","stack","url","href","timestamp","Date","toISOString","event","_event$reason","_event$reason2","reason","errorData","post","userAgent","navigator","language","platform","cookiesEnabled","cookieEnabled","screenSize","screen","width","height","viewportSize","innerWidth","innerHeight","existingToken","response","get","token","data","secure","sameSite","path","maxAge","sanitizeInput","input","options","sanitizeAndValidate","validatePassword","password","requiresAuth","publicPaths","some","publicPath","startsWith","isRouteAccessible","requiredRoles","userRole","length","includes","secureNavigate","requireAuth","isAuthenticated","encodeURIComponent","sanitizedPath","sanitizeUrl","localStorage","getItem","secureLogout","removeItem","sessionStorage","clear","secureRequest","method","headers","_error$response","_error$response2","status","pathname","value","Provider","fileName","_jsxFileName","lineNumber","columnNumber","_c","$RefreshReg$"],"sources":["C:/Users/pc/Desktop/INSY7314Shared/INSY7314/INSY7314/frontend/src/contexts/SecurityContext.js"],"sourcesContent":["import React, { createContext, useContext, useEffect, useState } from 'react';\nimport { useNavigate, useLocation } from 'react-router-dom';\nimport * as securityUtils from '../utils/security';\nimport { getCookie, setCookie, removeCookie } from '../utils/cookies';\nimport api from '../utils/api';\n\n// Create security context\nconst SecurityContext = createContext();\n\n// Custom hook to use security context\nexport const useSecurity = () => {\n  const context = useContext(SecurityContext);\n  if (!context) {\n    throw new Error('useSecurity must be used within a SecurityProvider');\n  }\n  return context;\n};\n\n// Security provider component\nexport const SecurityProvider = ({ children }) => {\n  const [csrfToken, setCsrfToken] = useState('');\n  const [isInitialized, setIsInitialized] = useState(false);\n  const [securityConfig, setSecurityConfig] = useState({\n    cspEnabled: true,\n    xssProtection: true,\n    clickjackingProtection: true,\n    contentTypeOptions: true,\n    hstsEnabled: process.env.NODE_ENV === 'production',\n  });\n\n  const navigate = useNavigate();\n  const location = useLocation();\n\n  // Initialize security features\n  useEffect(() => {\n    const initializeSecurity = async () => {\n      try {\n        // Fetch CSRF token from the server\n        await fetchCsrfToken();\n        \n        // Set up security headers\n        setupSecurityHeaders();\n        \n        // Set up global error handling\n        setupErrorHandling();\n        \n        // Protect against clickjacking\n        if (securityConfig.clickjackingProtection) {\n          document.addEventListener('DOMContentLoaded', () => {\n            if (window !== window.top) {\n              window.top.location = window.location;\n            }\n          });\n        }\n        \n        setIsInitialized(true);\n      } catch (error) {\n        console.error('Failed to initialize security:', error);\n      }\n    };\n\n    initializeSecurity();\n\n    // Clean up event listeners\n    return () => {\n      // Any cleanup if needed\n    };\n  }, []);\n\n  // Set up security headers\n  const setupSecurityHeaders = () => {\n    if (securityConfig.cspEnabled) {\n      const meta = document.createElement('meta');\n      meta.httpEquiv = \"Content-Security-Policy\";\n      meta.content = \"default-src 'self'; script-src 'self' 'unsafe-inline' 'unsafe-eval'; style-src 'self' 'unsafe-inline'; img-src 'self' data: https:; font-src 'self' data:; connect-src 'self';\";\n      document.head.appendChild(meta);\n    }\n\n    if (securityConfig.xssProtection) {\n      const metaXSS = document.createElement('meta');\n      metaXSS.httpEquiv = \"X-XSS-Protection\";\n      metaXSS.content = \"1; mode=block\";\n      document.head.appendChild(metaXSS);\n    }\n\n    if (securityConfig.contentTypeOptions) {\n      const metaCTO = document.createElement('meta');\n      metaCTO.httpEquiv = \"X-Content-Type-Options\";\n      metaCTO.content = \"nosniff\";\n      document.head.appendChild(metaCTO);\n    }\n\n    if (securityConfig.clickjackingProtection) {\n      const metaFrameOptions = document.createElement('meta');\n      metaFrameOptions.httpEquiv = \"X-Frame-Options\";\n      metaFrameOptions.content = \"DENY\";\n      document.head.appendChild(metaFrameOptions);\n    }\n\n    if (securityConfig.hstsEnabled && window.location.protocol === 'https:') {\n      const metaHSTS = document.createElement('meta');\n      metaHSTS.httpEquiv = \"Strict-Transport-Security\";\n      metaHSTS.content = \"max-age=31536000; includeSubDomains\";\n      document.head.appendChild(metaHSTS);\n    }\n  };\n\n  // Set up global error handling\n  const setupErrorHandling = () => {\n    // Global error handler\n    window.onerror = (message, source, lineno, colno, error) => {\n      console.error('Global error:', { message, source, lineno, colno, error });\n      // Log to error tracking service\n      logError({\n        type: 'global',\n        message: message.toString(),\n        source,\n        lineno,\n        colno,\n        stack: error?.stack,\n        url: window.location.href,\n        timestamp: new Date().toISOString()\n      });\n      return false; // Don't suppress default error handling\n    };\n\n    // Unhandled promise rejections\n    window.addEventListener('unhandledrejection', (event) => {\n      console.error('Unhandled rejection:', event.reason);\n      logError({\n        type: 'unhandled_rejection',\n        message: event.reason?.message || 'Unknown error',\n        stack: event.reason?.stack,\n        url: window.location.href,\n        timestamp: new Date().toISOString()\n      });\n    });\n  };\n\n  // Log security-related errors\n  const logError = async (errorData) => {\n    try {\n      await api.post('/api/logs/error', {\n        ...errorData,\n        userAgent: navigator.userAgent,\n        language: navigator.language,\n        platform: navigator.platform,\n        cookiesEnabled: navigator.cookieEnabled,\n        screenSize: `${window.screen.width}x${window.screen.height}`,\n        viewportSize: `${window.innerWidth}x${window.innerHeight}`,\n      });\n    } catch (error) {\n      console.error('Failed to log error:', error);\n    }\n  };\n\n  // Fetch CSRF token from the server\n  const fetchCsrfToken = async () => {\n    try {\n      // Check if we already have a valid token\n      const existingToken = getCookie('XSRF-TOKEN');\n      \n      if (existingToken) {\n        setCsrfToken(existingToken);\n        return existingToken;\n      }\n\n      // Fetch new token from the server\n      const response = await api.get('/api/csrf-token');\n      const { token } = response.data;\n      \n      // Store the token in a secure, HTTP-only cookie\n      setCookie('XSRF-TOKEN', token, {\n        secure: process.env.NODE_ENV === 'production',\n        sameSite: 'strict',\n        path: '/',\n        maxAge: 24 * 60 * 60 // 24 hours\n      });\n      \n      setCsrfToken(token);\n      return token;\n    } catch (error) {\n      console.error('Failed to fetch CSRF token:', error);\n      throw error;\n    }\n  };\n\n  // Sanitize user input\n  const sanitizeInput = (input, options = {}) => {\n    return securityUtils.sanitizeAndValidate(input, options);\n  };\n\n  // Validate password strength\n  const validatePassword = (password) => {\n    return securityUtils.validatePassword(password);\n  };\n\n  // Check if the current route requires authentication\n  const requiresAuth = (path) => {\n    const publicPaths = ['/login', '/register', '/forgot-password', '/reset-password'];\n    return !publicPaths.some(publicPath => path.startsWith(publicPath));\n  };\n\n  // Check if the current route is accessible based on user role\n  const isRouteAccessible = (requiredRoles = []) => {\n    // Get user role from your auth context or state\n    const userRole = 'user'; // Replace with actual user role\n    \n    if (requiredRoles.length === 0) return true;\n    if (!userRole) return false;\n    \n    return requiredRoles.includes(userRole);\n  };\n\n  // Secure navigation\n  const secureNavigate = (path, options = {}) => {\n    const { requireAuth = true, requiredRoles = [] } = options;\n    \n    if (requireAuth && !isAuthenticated()) {\n      // Redirect to login with a return URL\n      navigate(`/login?returnTo=${encodeURIComponent(path)}`);\n      return false;\n    }\n    \n    if (requiredRoles.length > 0 && !isRouteAccessible(requiredRoles)) {\n      // Redirect to not authorized page\n      navigate('/unauthorized');\n      return false;\n    }\n    \n    // Sanitize the path to prevent XSS\n    const sanitizedPath = securityUtils.sanitizeUrl(path) || '/';\n    navigate(sanitizedPath);\n    return true;\n  };\n\n  // Check if user is authenticated\n  const isAuthenticated = () => {\n    // Implement your authentication check here\n    // For example, check for a valid JWT token\n    const token = localStorage.getItem('authToken');\n    return !!token;\n  };\n\n  // Secure logout\n  const secureLogout = async () => {\n    try {\n      // Call logout API\n      await api.post('/api/auth/logout');\n      \n      // Clear local storage\n      localStorage.removeItem('authToken');\n      localStorage.removeItem('user');\n      \n      // Clear session storage\n      sessionStorage.clear();\n      \n      // Clear cookies\n      removeCookie('XSRF-TOKEN');\n      \n      // Redirect to login\n      navigate('/login');\n    } catch (error) {\n      console.error('Logout failed:', error);\n      // Even if API call fails, clear client-side auth state\n      localStorage.removeItem('authToken');\n      localStorage.removeItem('user');\n      sessionStorage.clear();\n      removeCookie('XSRF-TOKEN');\n      navigate('/login');\n    }\n  };\n\n  // Secure API request\n  const secureRequest = async (method, url, data = {}, options = {}) => {\n    try {\n      const response = await api({\n        method,\n        url,\n        data,\n        ...options,\n        headers: {\n          'X-Requested-With': 'XMLHttpRequest',\n          'X-CSRF-Token': csrfToken,\n          ...options.headers,\n        },\n      });\n      \n      return response;\n    } catch (error) {\n      if (error.response?.status === 401) {\n        // Handle unauthorized (token expired, etc.)\n        await secureLogout();\n        navigate(`/login?sessionExpired=true&returnTo=${encodeURIComponent(location.pathname)}`);\n      } else if (error.response?.status === 403) {\n        // Handle forbidden (insufficient permissions)\n        navigate('/unauthorized');\n      }\n      \n      throw error;\n    }\n  };\n\n  // Security context value\n  const value = {\n    isInitialized,\n    csrfToken,\n    securityConfig,\n    sanitizeInput,\n    validatePassword,\n    isAuthenticated,\n    secureNavigate,\n    secureLogout,\n    secureRequest,\n    logError,\n  };\n\n  return (\n    <SecurityContext.Provider value={value}>\n      {children}\n    </SecurityContext.Provider>\n  );\n};\n\nexport default SecurityContext;\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}